프로그래밍 언어는 컴퓨터에게 명령을 내리는 단순 도구다.

그래서 이번 챕터만 프로그래밍 언어에 대해서 설명을 진행한다.

# 태초

- 간단한 스위치를 조합하면 복잡한 불 논리를 표현할 수 있다는 사실로 CPU를 만들었다.
- 따라서 CPU는 0, 1만 구분할 수 있다.
- 대신 매우 단세포 생물이다. 간단한 연산, 다른 곳으로 옮기는 작업 말고는 못한다.
- BUT! CPU는 매우 빠르다. 단세포의 단점을 뛰어 넘는다. → 인간이 아무리 똑똑해도 CPU를 절대로 따라잡지 않는다.

<img width="697" height="294" alt="image" src="https://github.com/user-attachments/assets/f7bcb64b-f3d4-444a-802e-1b1bf4485521" />

- 천공카드로 컴퓨터 작업을 제어했었다.

# 어셈블리어 두둥장

- 인간은 CPU의 기계어와 해당 특정 작업을 간단하게 대응시켰다.
- 처음으로 인간이 인식할 수 있는 언어가 탄생

```nasm
      mov    ax, @data
      mov    ds, ax

      mov    ah, 9
      mov    dx, offset hello_message
      int    21h
      
      
      DATA 세그먼트를 DS에 설정하고,
			DOS 인터럽트 21h의 09번 기능으로
			$ 끝 문자열을 출력하는 코드
			
			
			System.out.println("Hello, world");
```

- 하지만 여전히 저수준 언어
    - 저수준 : 너네가 모든 걸 신경써야 한다.(순정)
- 명령문(statement), 매개변수(parameter) 등이 탄생하게 된다.
- 그러다가 if문 안에 if문..if문… 재귀를 발견한다.
- 그러다가 트리를 발견하고…

<img width="486" height="413" alt="image" src="https://github.com/user-attachments/assets/e3981bf5-d124-446e-b422-5273a8605799" />


- 이 작업을 수행하는 녀석의 이름이 ‘컴파일러’가 되었다. → 이렇게 고급 프로그래밍 언어가 발명되었다.
- 이 시점부터 인간이 인식할 수 있는 언어를 사용하여 코드를 작성하고, 컴파일러가 코드를 기계어로 번역했다. → 산업이 커졌다!

# 해석형….

- 하지만 CPU마다 생성된 기계 명령어를 서로 해석할 수 없다.
    - 박기현이 만든 두쫀쿠를 심보경은 이해할 수 없다.(?)
    
    <img width="476" height="235" alt="image" src="https://github.com/user-attachments/assets/eb7004a7-f9de-4100-908a-96bb75f8ad97" />

    
- 그러면 통용되는 인터페이스가 필요하지 않을까?라는 생각이 든다.
- 사람이 작성한 코드를 각 CPU에 맞게 실행할 수 있는 `가상머신`을 만들었다. `인터프리터`라고도 불린다.
- 이제 우리가 작성한 코드를 어떠한 플랫폼에서도 실행할 수 있게 된다!!
    - → 이게 JVM이 생각나는군요…

# 컴파일러

- 고수준 언어를 저수준 언어로 번역하는 프로그램.
- 사람이 작성한 코드는 소스파일이라고 불린다. → 이 파일을 컴파일러에게 먹이로 주면 꼭꼭 씹어서 실행 파일 형태로 뱉어낸다.

```java
int sum = a + 10;

위는 일반적인 코드.

int → (키워드 토큰)
sum → (식별자 토큰: 변수명/함수명 같은 이름)
= → (연산자 토큰)
a → (식별자 토큰)
+ → (연산자 토큰)
10 → (숫자 리터럴 토큰)
; → (구분자 토큰)

위는 코드를 의미있는 단위로 쪼개놓은 토큰
```

- 어휘분석은 소스코드를 문자 단위로 읽어서 토큰으로 바꾸는 과정이다.
- 어휘분석 다음은 구문 분석을 진행한다.

```java
while (표현식)
{
	반복 내용
}
```

- 위 코드에서 while 다음 토큰은 ‘(’라는 것을 알고 있는 상태로 기다린다. 하지만 ‘(’ 외의 토큰이 나오면 문법 오유를 보고하기 시작한다.

# 링커

- 압축 프로그램이 파일 여러 개를 하나의 압축 파일로 묶는 것처럼, 컴파일러가 생성한 여러 개의 파일을 하나로 묶어 최종 실행 파일을 생성한다.
- 윈도우에서 흔히 보는 exe파일도 컴파일러가 만든 대상 파일을 묶어서 하나의 최종 파일로 만든 것이다.

### 심볼 해석

- 심볼 : 링커가 모듈 간 연결을 위해 다루는 이름이다. 대표적으로 전역 변수와 함수(및 외부 참조)가 해당
- 링커의 심볼 관심사는 모듈 경계를 넘나드는 이름(전역/외부참조)이다.
- 함수 내에 지역변수 같은 건 링커의 관심 대상이 아니다.

```solidity
심볼 해석은 결국 “**undefined 심볼을 어디 defined 심볼에 붙일지 매칭하는 과정**”
```

**A.c → 컴파일하면 A.o**

```c
extern int b;
int func_a(int x);

int func_b() {
  return func_a(b);
}

```

**B.c → 컴파일하면 B.o**

```c
int b = 10;
int func_a(int x) { return x + 1; }
```

- A.c안에 b와 func_a는 미정의(Undefined)가 생긴다.

```smalltalk
심볼테이블

defined: func_b
undefined: b, func_a
```

이때 심볼해석을 통해 어디 있는지 찾아서 연결해야 한다.

- A.o의 undefined b → B.o의 defined b
- A.o의 undefined func_a → B.o의 defined func_a

# 정적, 동적 라이브러리

### 정적 라이브러리

- 여러개의 코드를 컴파일 한 a.o, b.o, c.o 파일을 링커를 이용해서 하나의 정적 라이브러리를 만든다.

<img width="697" height="217" alt="image" src="https://github.com/user-attachments/assets/d74dc0fc-9e81-4f24-8aea-915e2ff5ee7c" />


- 이후 실행 파일을 생성할 때는 자신의 코드만 컴파일해서, 미리 컴파일 된 정적 라이브러리는 다시 컴파일하지 않아도 된다.

<img width="698" height="216" alt="image" src="https://github.com/user-attachments/assets/5af27ba4-7be5-41d2-9726-d0e6bbb0594c" />


- 하지만 모든 곳에서 동일한 정적 라이브러리를 넣어둬야 하기에 중복 데이터가 많이 생긴다.
- 정적 라이브러리를 업데이트할 때 모든 사용 지점에서 업데이트 해야한다.

이 어려운 관리를 해결할 수 있는 방법이 동적 라이브러리를 사용하는 것이다.

### 동적 라이브러리

- 윈도우에서 흔히 보는 dll파일이 동적 라이브러리다.
- 리눅스에서는 .so 확장자를 사용, 접두사로는 lib 사용

정적 라이브러리를 사용하면 라이브러리 내용을 모두 복사하여 사용하게 되지만, 동적 라이브러리를 사용하면 라이브러리 이름, 심벌 테이블, 재배치 정보 등 필수 정보만 실행파일에 포함한다.

즉, 정적 라이브러리에 비해 실행 파일의 크기를 확실히 줄일 수 있는 게 큰 장점이다.

<img width="695" height="733" alt="image" src="https://github.com/user-attachments/assets/a6c35041-4b84-4b1f-accf-cfd2b94e8dd6" />


- 정적 라이브러리는 이랬다면

<img width="657" height="689" alt="image" src="https://github.com/user-attachments/assets/4d285e18-b509-4c7f-a799-d50112fe7c3d" />


- 동적 라이브러리는 공간을 효율적으로 사용할 수 있게 된다.

### 동적 라이브러리 장점

- 복사본 하나만 저장되면 여러 프로그램에서 사용이 가능하다.
- 수정이 발생해도 컴파일만 하면 된다.
- 여러 언어의 장점을 이용할 수 있다.
    - c(빠름)로 동적 라이브러리를 만들어 파이썬 프로젝트에서 사용할 수도 있다.

### 동적 라이브러리 단점

- 프로그램이 적재되는 시간, 실행 시간에 링크되기 때문에 정적에 비해 성능이 약간 떨어짐.
- 동적 라이브러리 코드는 절대 주소를 참조할 수 없다.
    - → 메모리에 올라갈 때 위치가 정해지기 때문

# 재배치(Relocation)

```markdown
컴파일된 코드/데이터 안에 있는 “주소 미정(placeholder)” 부분을 찾아서,
최종 배치 결과에 맞는 실제 값(주소 또는 오프셋)으로 채워 넣는 작업.
```

- 모든 함수/전역변수는 “어딘가”에 놓이고, 그 위치를 가리키는 값(주소/오프셋)이 필요하다.

예를 들어 `foo()`를 호출하는 기계어가 있다고 하자.

```nasm
call ???    ; foo로 점프해야 하는데 지금은 모름
```

### 컴파일 단계: “자리” + “메모(재배치 엔트리)”를 남긴다

- 컴파일러는 `foo`가 최종적으로 어디에 배치될지 아직 모르기 때문에,
    
    기계어에 임시값(더미)을 넣어 **자리를 확보**해둔다.
    

```nasm
call 0x00   ; 더미 값 
```

- 그리고 `.o` 파일에 **재배치 정보(relocation entry)** 를 함께 기록한다.

> “코드의 이 위치(offset)에 있는 값을, 나중에 `foo`의 주소(또는 상대 오프셋)로 고쳐라”
> 

즉 `0x00` 자체가 중요한 게 아니라,

**“여기는 링커가 나중에 채워야 하는 자리다”** 라는 표시 + 메모가 핵심이다.

### 링크 단계: 링커가 최종 배치를 정하고 패치한다 (링커 재배치)

링커는 여러 `.o` 파일을 합쳐 실행 파일을 만들면서:

1. **레이아웃 결정**: `.text/.data` 등을 어떤 순서로 어디에 둘지 정함
2. **심볼 해결**: `foo`가 어디에 정의돼 있는지 찾아 최종 위치를 확정함
3. **재배치 수행**: relocation entry를 훑으며, placeholder 자리를 실제 값으로 패치함
- 이때 “실제 값”은 환경/아키텍처에 따라
    
    **절대주소**일 수도 있고, **상대 오프셋**일 수도 있다.
    

---

# 가상메모리(Virtual Memory)

<img width="382" height="538" alt="image" src="https://github.com/user-attachments/assets/146c96af-7440-4b88-8ff9-9cc309ab4562" />


```smalltalk
프로그램이 쓰는 주소(가상주소, VA)와 실제 RAM 주소(물리주소, PA)를 분리하는 방식.
각 프로세스는 자기만의 가상주소 공간을 가진다.
```

- “프로세스마다 같은 주소를 쓰면 충돌하는 거 아냐?” → **안 충돌한다.**
- 이유: 같은 숫자의 주소라도(예: VA 0x400000),
    
    프로세스마다 **물리 메모리로 매핑되는 대상이 다를 수 있기 때문**이다.
    

> 즉, “주소 숫자(VA)는 같아도, 실제 RAM(PA)은 다를 수 있다.”
> 

또한 코드 영역이 “항상 0x400000”처럼 고정이라고 단정하면 오해가 생길 수 있다.

- 많은 환경에서 코드가 낮은 주소(예: 0x400000 근처)에서 시작하는 경우가 **있지만**
- PIE/ASLR 설정에 따라 **실행할 때마다 베이스 주소가 달라질 수 있다.**

---

# 페이지 테이블(Page Table)

- 페이지 테이블은 **가상주소(VA) → 물리주소(PA)** 변환표다.
- CPU가 어떤 VA에 접근하면, MMU가 페이지 테이블을 보고 대응되는 PA를 찾아 실제 RAM에 접근한다.

그래서 예를 들면:

- 프로세스 A의 페이지 테이블: `VA 0x400000 → PA 0x123...`
- 프로세스 B의 페이지 테이블: `VA 0x400000 → PA 0xABC...`

처럼 같은 VA라도 프로세스마다 완전히 다르게 매핑될 수 있다.

---

# 한 문장 연결(재배치 ↔ 가상메모리)

링커는 실행 파일 내부 기준(가상주소 관점)으로 함수/변수의 위치를 확정하고 재배치로 코드를 패치한다.

그리고 실제 실행 시점에는 OS가 페이지 테이블을 통해 그 가상주소들을 물리 메모리에 매핑한다.

그래서 프로세스마다 “같은 가상주소”를 써도 충돌하지 않는다.
